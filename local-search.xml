<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>EasyExcel</title>
    <link href="/2020/06/15/EasyExcel/"/>
    <url>/2020/06/15/EasyExcel/</url>
    
    <content type="html"><![CDATA[<h1 id="EasyExcel"><a href="#EasyExcel" class="headerlink" title="EasyExcel"></a>EasyExcel</h1><blockquote><p>应用场景</p></blockquote><p>1、数据导入：减轻录入工作量</p><p>2、数据导出：统计信息归档</p><p>3、数据传输：异构系统之间数据传输</p><h2 id="一、写入"><a href="#一、写入" class="headerlink" title="一、写入"></a>一、写入</h2><blockquote><p>1、创建实体类用来读取数据</p></blockquote><p>​    //设置字段名<br>​    @ExcelProperty(“学生编号”)</p><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoData</span> </span>&#123;    <span class="hljs-comment">//设置字段名</span>    <span class="hljs-meta">@ExcelProperty</span>(<span class="hljs-string">"学生编号"</span>)    <span class="hljs-keyword">private</span> String sno;    <span class="hljs-meta">@ExcelProperty</span>(<span class="hljs-string">"学生姓名"</span>)    <span class="hljs-keyword">private</span> String name;&#125;</code></pre><blockquote><p>2、实例</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@org</span>.junit.Test   <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;       List&lt;DemoData&gt; list  = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();       <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;           DemoData d = <span class="hljs-keyword">new</span> DemoData();           d.setName(<span class="hljs-string">"lucy"</span>);           d.setSno(<span class="hljs-string">""</span>+i);           list.add(d);       &#125;       <span class="hljs-comment">//指定写入文件路径</span>       String fileName = <span class="hljs-string">"G:/t.xlsx"</span>;       EasyExcel.write(fileName, DemoData.class).sheet("学生").doWrite(list);   &#125;</code></pre><h2 id="二、读取"><a href="#二、读取" class="headerlink" title="二、读取"></a>二、读取</h2><blockquote><p>1、创建实体类用来读取数据</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReadData</span> </span>&#123;    <span class="hljs-comment">//设置字段</span>    <span class="hljs-meta">@ExcelProperty</span>(value = <span class="hljs-string">"一级标题"</span>,index = <span class="hljs-number">0</span>)    <span class="hljs-keyword">private</span> String firstName;    <span class="hljs-meta">@ExcelProperty</span>(value = <span class="hljs-string">"二级标题"</span>,index = <span class="hljs-number">1</span>)    <span class="hljs-keyword">private</span> String secondName;&#125;</code></pre><blockquote><p>2、实例操作</p></blockquote><pre><code class="hljs java"><span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">readFile</span><span class="hljs-params">(MultipartFile file,EduSubjectService eduSubjectService)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;            InputStream inputStream = file.getInputStream();            <span class="hljs-comment">//读取文件（使用到监听器） 参数说明：文件流,数据实体类,监听器)</span>            EasyExcel.read(inputStream, ReadData<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">new</span> <span class="hljs-title">ExcelListener</span>(<span class="hljs-title">eduSubjectService</span>)).<span class="hljs-title">sheet</span>().<span class="hljs-title">doRead</span>()</span>;            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;    &#125;</code></pre><blockquote><p>3、配置监听器</p><p>继承— AnalysisEventListener&lt;&gt;类</p></blockquote><pre><code class="hljs java">** * 实现 ExcelListener */<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcelListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AnalysisEventListener</span>&lt;<span class="hljs-title">ReadData</span>&gt; </span>&#123;    <span class="hljs-keyword">private</span> EduSubjectService service;    <span class="hljs-comment">/**</span><span class="hljs-comment">     *  获取读取excel内容</span><span class="hljs-comment">     *       :为一行一行读取</span><span class="hljs-comment">     *  readData.getFirstName()//获取第一个字段</span><span class="hljs-comment">     *  readData.getSecondName()//获取第二个字段</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invoke</span><span class="hljs-params">(ReadData readData, AnalysisContext analysisContext)</span> </span>&#123;        System.out.println(<span class="hljs-string">"---&gt;"</span>+readData);        EduSubject firstField = exisFirstField(readData.getFirstName());        System.out.println(firstField);        String id = firstField.getId();        <span class="hljs-keyword">if</span>(firstField==<span class="hljs-keyword">null</span>)&#123;<span class="hljs-comment">//如果数据库没有不重复 添加</span>            firstField = <span class="hljs-keyword">new</span> EduSubject();            firstField.setTitle(readData.getFirstName());            firstField.setParentId(<span class="hljs-string">"0"</span>);            firstField.setSort(<span class="hljs-number">1</span>);            service.save(firstField);            System.out.println(<span class="hljs-string">"添加"</span>);        &#125;        <span class="hljs-comment">//同一转换为小写</span>        String secondName = readData.getSecondName().toLowerCase();        EduSubject secondField = exisSecondField(secondName,id);        System.out.println(secondField);        <span class="hljs-keyword">if</span>(secondField == <span class="hljs-keyword">null</span> )&#123;<span class="hljs-comment">//如果数据库没有不重复 添加</span>            secondField = <span class="hljs-keyword">new</span> EduSubject();            secondField.setTitle(secondName);            secondField.setParentId(firstField.getId());            secondField.setSort(<span class="hljs-number">1</span>);            service.save(secondField);        &#125;    &#125;    <span class="hljs-comment">//读取完成后执行</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfterAllAnalysed</span><span class="hljs-params">(AnalysisContext analysisContext)</span> </span>&#123;        System.out.println(<span class="hljs-string">"添加成功"</span>);    &#125;    <span class="hljs-comment">//判断数据库中是否有一级字段</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> EduSubject <span class="hljs-title">exisFirstField</span><span class="hljs-params">(String name)</span></span>&#123;        QueryWrapper&lt;EduSubject&gt; wrapper  = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();        wrapper.eq(<span class="hljs-string">"title"</span>,name);        wrapper.eq(<span class="hljs-string">"parent_id"</span>,<span class="hljs-string">"0"</span>);        EduSubject one = service.getOne(wrapper);        <span class="hljs-keyword">return</span> one;    &#125;    <span class="hljs-comment">//判断是否有二级字段</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> EduSubject <span class="hljs-title">exisSecondField</span><span class="hljs-params">(String name,String id)</span></span>&#123;        QueryWrapper&lt;EduSubject&gt; wrapper  = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();        wrapper.eq(<span class="hljs-string">"title"</span>,name);        wrapper.eq(<span class="hljs-string">"parent_id"</span>,id);        EduSubject one = service.getOne(wrapper);        <span class="hljs-keyword">return</span> one;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ExcelListener</span><span class="hljs-params">(EduSubjectService service)</span></span>&#123;        <span class="hljs-keyword">this</span>.service = service;    &#125;&#125;</code></pre><hr><p><a href="https://gitee.com/xincen9/easyExcel" target="_blank" rel="noopener">实例源码地址</a></p>]]></content>
    
    
    <categories>
      
      <category>工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>EasyExcel</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux</title>
    <link href="/2020/06/15/Linux/"/>
    <url>/2020/06/15/Linux/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h1><h3 id="一、linux目录介绍"><a href="#一、linux目录介绍" class="headerlink" title="一、linux目录介绍"></a>一、linux目录介绍</h3><ol><li><p>​    / 表示根目录</p></li><li><p>~ 表示/root</p></li><li><p><u>etc 存放系统配置目录</u></p></li><li><p>home 除了root 以为所有用户默认在home 下新建一个以用户<br>名做为文件夹名称的文件夹</p></li><li><p>usr 所有用户安装的软件都放到这个文件夹中</p><p>​    5.1 在usr/local 下新建一个tmp。</p></li></ol><h3 id="二、常用命令"><a href="#二、常用命令" class="headerlink" title="二、常用命令"></a>二、常用命令</h3><ol><li><p>​    pwd 打印当前所在目录，全路径</p></li><li><p>​    mkdir -r 新建一个文件夹</p><ol><li>mkdir -r 文件夹名/文件夹名     可以多子文件夹创建</li></ol></li><li><p>​    ll 详细列表文件名  ls 平铺</p></li><li><p>​    touch “文件名”  创建一个空白文件</p></li><li><p>​    vi  “文件名”   vim “文件名”   编辑文件 </p><ol><li>​    如果编辑的文件不存在，那么将会有创建功能</li><li>​    进入编辑模式，需要insert 或者” i “ 进行启用</li><li>​    编辑完成 按 “ esc “ 退出编辑模式</li><li>​    输入命令 “ :wq” 保存内容并退出</li><li>​    输入命令 “ :q  “ 不保存退出</li><li>​    输入命令  “  :q! “ 强制退出，不保存</li></ol></li><li><p>​    cat “/usr/local/tmp/demo” 查看文件内容</p></li><li><p>​    head “/usr/local/tmp/demo”  默认查看文件前十行内容</p><ol><li>​    head -2 “/usr/local/tmp/demo”  查看文件前2行内容</li></ol></li><li><p>​    tail  “/usr/local/tmp/demo”  默认查看文件后十行内容</p><ol><li>​    tail  -2 “/usr/local/tmp/demo”  默认查看后2行内容</li></ol></li><li><p>​    tailf  “/usr/local/tmp/demo”  动态查看文件默认后十行</p></li><li><p>​    rm “文件”  删除文件</p><ol><li>rm -f 不询问 强制删除文件</li><li>rm -rf 不询问 强制删除文件夹</li></ol></li><li><p>​    cp  “文件”  “新路径”  文件复制</p></li><li><p>​    mv  “文件” “新路径”  文件剪切</p><ol><li>mv  “文件” “新路径+新文件名”  可以重命名文件</li></ol></li><li><p>​    echo  ‘内容’ &gt;&gt; 文件名   向文件中添加一些内容</p></li><li><p>​    reboot  重启</p></li><li><p>​    tar  -zxvf  文件名     解压缩 压缩包</p></li><li><p>​    tar  -zcvf  文件名     压缩文件</p></li><li><p>​    ctrl+C   中断</p></li><li><p>​    clear   清屏</p></li><li><p>​    ifconfig  查看ip地址 网络段</p></li><li><p>​    ./ 执行文件   在linux中执行可执行文件</p></li><li><p>​    source /etc/profile   解析文件</p></li><li><p>​    service iptables restart    重启服务</p><ol><li>start    启动</li><li>restart  重启</li><li>stop     停止</li></ol></li><li><p>ps -ef | grep java 查看进程</p></li></ol><h3 id="三、JDK配置"><a href="#三、JDK配置" class="headerlink" title="三、JDK配置"></a>三、JDK配置</h3><ol><li><p>上传Linux版本jdk压缩包 到服务器</p></li><li><p>解压压缩包，并将解压后的压缩包 复制到 # /usr/local/jdk</p></li><li><p>配置环境变量，执行命令 进入修改</p><ol><li><u>vim /etc/profile</u> </li></ol></li><li><p>进入修改文件</p><ol><li><p>分隔符使用冒号：</p></li><li><p>$ 表示引用</p></li><li><p>代码如下</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/jdk<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$JAVA_HOME</span>/bin:$PATH</code></pre></li></ol></li><li><p>执行完成，重新解析文件  </p><ol><li><u>source /etc/profile</u></li></ol></li></ol><p>#—————————————————版本centos6.5————————————————————————————</p><h3 id="四、Tomcat配置"><a href="#四、Tomcat配置" class="headerlink" title="四、Tomcat配置"></a>四、Tomcat配置</h3><ol><li><p>上传Linux版本tomcat压缩包 到服务器</p></li><li><p>解压压缩包，并将解压后的压缩包 复制到 # /usr/local/tomcat</p></li><li><p>配置环境变量，执行命令 进入修改</p><ol><li><p><u>vim /etc/profile</u> </p></li><li><p>代码如下</p><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">TOMCAT_HOME</span>=/usr/local/tomcat<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">CATALINA_HOME</span>=/usr/local/tomcat</code></pre></li></ol></li><li><h5 id="修改服务配置-放行端口8080（供客户端访问）"><a href="#修改服务配置-放行端口8080（供客户端访问）" class="headerlink" title="修改服务配置 放行端口8080（供客户端访问）"></a>修改服务配置 放行端口8080（供客户端访问）</h5><ol><li><p>vim /etc/sysconfig/iptables</p></li><li><p>复制包含22一行代码  将22替换8080</p><p>2.1 例如 8080:9000  代表放行8080–到9000端口</p></li><li><p>修改完成，重启服务</p><p><u>3.1 servic iptables restart</u></p></li><li><p>启动tomcat,进入到tomcat/bin 文件夹</p></li><li><p>./startup.sh   直接启动</p></li><li><p>./startup.sh &amp; tailf /usr/local/tomcat/logs/catalina.out   启动并打印信息</p></li></ol></li></ol><h3 id="mysql-执行命令"><a href="#mysql-执行命令" class="headerlink" title="mysql 执行命令"></a>mysql 执行命令</h3><ol><li><p>进入mysqll</p><ol><li>mysql -u 用户名 -p密码 (p后面不能隔空格)</li><li>mysql -u root -p123456</li></ol></li><li><p>选择数据库</p><ol><li>use mysql</li></ol></li><li><p>初始账户修改密码</p><ol><li><p>进入mysql如下</p><pre><code class="hljs sql">//选择数据库<span class="hljs-keyword">use</span> mysql;//修改密码<span class="hljs-keyword">update</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">set</span> <span class="hljs-keyword">password</span>= <span class="hljs-keyword">passworD</span> (<span class="hljs-string">"123456"</span>) <span class="hljs-keyword">where</span> <span class="hljs-keyword">user</span>=<span class="hljs-string">'root'</span>;</code></pre></li></ol></li><li><p>创建数据库 命令</p><ol><li>create database &lt;数据库名&gt; </li><li>例如：create database xhkdb;</li></ol></li></ol><p>#—————————————————版本centos6.5————————————————————————————</p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="五、文件下载与上传"><a href="#五、文件下载与上传" class="headerlink" title="五、文件下载与上传"></a>五、文件下载与上传</h2><ol><li><p>在linux 上使用</p><pre><code class="hljs shell">yum install -y lrzsz  // yum 安装完毕之后可以直接rz尝试使用</code></pre></li></ol><ol start="2"><li><p>输入命令” rz “ 回车会上传文件</p><pre><code class="hljs shell">sz</code></pre></li><li><p>输入命令” sz 文件 “ 会下载文件</p><pre><code class="hljs shell">sz springboot-sixth-example-0.0.1-SNAPSHOT.jar</code></pre></li></ol><p><a href="https://www.cnblogs.com/pipiyan/p/10471242.html" target="_blank" rel="noopener">如有出错请参考</a></p><h2 id="六、centos7-网络配置"><a href="#六、centos7-网络配置" class="headerlink" title="六、centos7 网络配置"></a>六、centos7 网络配置</h2><ol><li><p>DHCP–输入命令dhclient，可以自动获取一个IP地址</p></li><li><p>静态网路配置</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">输入命令进入配置文件</span>vim /etc/sysconfig/network-scripts/ifcfg-ens33vi /etc/sysconfig/network-scripts/ifcfg-ens33<span class="hljs-meta">#</span><span class="bash">将ONBOOT=no改为yes，</span><span class="hljs-meta">#</span><span class="bash">将BOOTPROTO=dhcp改为BOOTPROTO=static,</span><span class="hljs-meta">#</span><span class="bash">并在后面增加几行内容：</span>IPADDR=192.168.75.131 # 设置本虚拟机的ip  根据网段设置NETMASK=255.255.255.0GATEWAY=192.168.75.2 #192.168.75 根据网段填写 2为固定DNS1=119.29.29.29</code></pre></li><li><p><a href="https://blog.csdn.net/akipa11/article/details/81414875" target="_blank" rel="noopener">参考博客</a></p></li></ol><p>释放端口</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看防火墙状态</span>查看防火墙状态 systemctl status firewalld开启防火墙 systemctl start firewalld  关闭防火墙 systemctl stop firewalld开启防火墙 service firewalld start 若遇到无法开启先用：systemctl unmask firewalld.service 然后：systemctl start firewalld.service<span class="hljs-meta">#</span><span class="bash">添加指定需要开放的端口：</span>firewall-cmd --add-port=80/tcp --permanent<span class="hljs-meta">#</span><span class="bash">重载入添加的端口：</span>firewall-cmd --reload<span class="hljs-meta">#</span><span class="bash">查询指定端口是否开启成功：</span>firewall-cmd --query-port=8080/tcp<span class="hljs-meta">#</span><span class="bash">移除指定端口：</span>firewall-cmd --permanent --remove-port=123/tcp</code></pre><p><a href="https://blog.csdn.net/realjh/article/details/82048492" target="_blank" rel="noopener">参考博客</a></p><h2 id="八、缺少命令"><a href="#八、缺少命令" class="headerlink" title="八、缺少命令"></a>八、缺少命令</h2><ol><li><p>vim ：执行命令</p><pre><code class="hljs shell">yum -y install vim-enhanced</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git--基础命令</title>
    <link href="/2020/06/15/Git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/06/15/Git-%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="一、基本的使用"><a href="#一、基本的使用" class="headerlink" title="一、基本的使用"></a>一、基本的使用</h2><ol><li><p>安装git后进行全局的设置</p><pre><code class="hljs shell">git config --global user.name "xincen" #用户名git config --global user.email "344751639@qq.com" #邮箱<span class="hljs-meta">#</span><span class="bash">查看信息</span>git config -l</code></pre></li><li><p>基本指令</p><pre><code class="hljs shell">创建版本仓库:创建一个文件夹，cmd指向该文件夹，然后执行git init #初始化仓库git add . #增加库目录中所有文件git commit -m "this is my first git" #提交到git到缓冲区中  -m "说明"git status #查看文件状态</code></pre></li><li><p>日志</p><pre><code class="hljs shell">git log #查看所有的日志git log --oneline #简洁日志</code></pre></li><li><p>版本回退</p><pre><code class="hljs shell">git reset --hard head~ #退回上一个版本git reset --hard head~2 #退回上两个版本  以此类推</code></pre></li><li><p>分支</p><pre><code class="hljs shell">git branch dev #创建一个新的分支  分支数据会克隆当前分支git checkout dev #切换分支git branch #查看分支git merge dev #合并分支</code></pre></li></ol><h2 id="二、远程仓库"><a href="#二、远程仓库" class="headerlink" title="二、远程仓库"></a>二、远程仓库</h2><p> 连接码云—GitHub</p><h3 id="1-设置秘钥–加密传输数据"><a href="#1-设置秘钥–加密传输数据" class="headerlink" title="1. 设置秘钥–加密传输数据"></a>1. 设置秘钥–加密传输数据</h3><pre><code class="hljs shell">ssh-keygen -t rsa -C "344751639@qq.com" <span class="hljs-meta">#</span><span class="bash"> 然后一直回车 即可 -C后<span class="hljs-string">"可以随意写一个，作为key的title而 已，无关紧要"</span></span>最后:在C:\Users\主机名\.ssh目录下生产秘钥文件，id_ rsa是私钥，不能泄露出去，id_ rsa.pub 是公钥，可以放心地告诉任何人。登录GitHub，在账户设置中，选择"SSH Keys" ,在Title中随便填写一个，在Key中填写id_ rsa. pub文件中的所有内容即可。</code></pre><h3 id="2-关联远程仓库"><a href="#2-关联远程仓库" class="headerlink" title="2. 关联远程仓库"></a>2. 关联远程仓库</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加远程库  <span class="hljs-comment">#远程仓库别名#库ssh地址</span></span>git remote add origin git@github.com :zanghongjiu99/ repo.gitgit remote -V # 查看关联的所有远程库git remote show origin #关联远程库后，本地分支和远程分支的对应关系git remote remove origin <span class="hljs-meta">#</span><span class="bash">删除关联</span>git remote rename origin origin2 #重命名</code></pre><h3 id="3-Push–上传分支数据"><a href="#3-Push–上传分支数据" class="headerlink" title="3. Push–上传分支数据"></a>3. Push–上传分支数据</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">将本地的master分支上传 对应仓库中的master分支</span>git push -u origin +master</code></pre><h3 id="4-Pull–下载分支"><a href="#4-Pull–下载分支" class="headerlink" title="4. Pull–下载分支"></a>4. Pull–下载分支</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">语法格式: git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;</span>git pull origin master:master</code></pre><hr><h2 id="三、Idea-上传"><a href="#三、Idea-上传" class="headerlink" title="三、Idea 上传"></a>三、Idea 上传</h2><p> 在使用idea上传时如果被拒绝，先pull–&gt;将仓库中的文件下载再上传</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">主要问题是，在工程里面需要先和gitee上的仓库进行合并，push才能成功</span>git pull origin master --allow-unrelated-histories</code></pre><p>使用</p><pre><code class="hljs shell">ssh-keygen -t rsa -C "xincen@qq.com"git remote add origin git@gitee.com:xc__cn/first_git.gitgit push -u origin +master</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cron--定时器</title>
    <link href="/2020/06/15/Cron-%E5%AE%9A%E6%97%B6%E5%99%A8/"/>
    <url>/2020/06/15/Cron-%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="Cron"><a href="#Cron" class="headerlink" title="Cron"></a>Cron</h1><blockquote><p>定时器</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * cron 定时器</span><span class="hljs-comment"> */</span><span class="hljs-meta">@Component</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScheduledTask</span> </span>&#123;    <span class="hljs-meta">@Autowired</span>    <span class="hljs-keyword">private</span> DailyService dailyService;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 测试每5秒之心</span><span class="hljs-comment"></span><span class="hljs-comment">    <span class="hljs-doctag">@Scheduled</span>(cron = "0/5 * * * * ?  ")</span><span class="hljs-comment">    public void test()&#123;</span><span class="hljs-comment">        System.out.println("执行5秒"+new Date());</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 每天凌晨00点执行</span><span class="hljs-comment">     * springboot 整合cron 表达式只能6位 不能超过不然会报错</span><span class="hljs-comment">     */</span>    <span class="hljs-meta">@Scheduled</span>(cron = <span class="hljs-string">"0 0 0 * * ? "</span>)    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">task</span><span class="hljs-params">()</span></span>&#123;        String day = DateUtil.formatDate(DateUtil.addDays(<span class="hljs-keyword">new</span> Date(), -<span class="hljs-number">1</span>));        dailyService.createDaily(day);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>工具类</category>
      
    </categories>
    
    
    <tags>
      
      <tag>cron</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2020/06/15/JUC/"/>
    <url>/2020/06/15/JUC/</url>
    
    <content type="html"><![CDATA[<h1 id="JUC"><a href="#JUC" class="headerlink" title="JUC"></a>JUC</h1><p><a href="https://gitee.com/xc__cn/basics/tree/juc/" target="_blank" rel="noopener">所有实例源码地址</a></p><h2 id="一、基本了解"><a href="#一、基本了解" class="headerlink" title="一、基本了解"></a>一、基本了解</h2><blockquote><p>什么是JUC</p></blockquote><ol><li>是对多线程的进一步优化，是java.util.concurrten 包的缩写</li></ol><blockquote><p>进程、线程</p></blockquote><p>进程：什么是进程？如打开一个应用程序，在后台运行的qq.exe就是一个程序、一个进程至少包含一个线程</p><p>线程：线程是在一个进程中有多条线程进行处理数据</p><blockquote><p>概念理解—&gt;并发、并行</p></blockquote><ol><li><p>并发：cpu的一核 分别取执行多条线程，底层实现原理（jvm的pc寄存器）</p><p>通俗解释：并发是两个队列交替使用一台咖啡机</p></li><li><p>并行：多个线程或者进程同时进行工作</p><p>通俗解释：并行是两个队列同时使用两台咖啡机</p></li></ol><blockquote><p>线程有几种状态</p><ol><li>新生—&gt;new</li><li>运行—&gt;Runnable</li><li>阻塞—&gt;blockd</li><li>等待—&gt;awiting</li><li>超时等待—&gt;TIMED_WAITING</li><li>终 止—&gt;TERMINATED</li></ol></blockquote><blockquote><p>创建线程有几种方式？  4中</p></blockquote><ol><li>继承Thread类创建线程</li><li>implment实现Runnable接口创建线程</li><li>使用Callable和Future创建线程</li><li>使用线程池创建</li></ol><h2 id="二、锁"><a href="#二、锁" class="headerlink" title="二、锁"></a>二、锁</h2><blockquote><p>传统锁 synchronized 和Lock锁</p><ol><li>非静态锁，锁的为对象，对象可以有多个</li><li>静态锁，锁的为类，类只能有一个</li></ol></blockquote><pre><code>&gt; 区别 1. Synchronized 内置的Java关键字， Lock 是一个Java类      2. Synchronized 无法判断获取锁的状态，Lock 可以判断是否获取到了锁               3. Synchronized 会自动释放锁，lock 必须要手动释放锁！如果不释放锁，死锁                 4. Synchronized 线程 1（获得锁，阻塞）、线程2（等待，傻傻的等）；Lock锁就不一定会等待下去；           5. Synchronized     可重入锁，不可以中断的，非公平；Lock ，可重入锁，可以  判断锁，非公平（可以自己设置）；                6. Synchronized     适合锁少量的代码同步问题，Lock 适合锁大量的同步代码！</code></pre><blockquote><p>公平锁和非公平锁</p><p>公平锁：资源加载非常公平，不会插队。</p><p>非公平锁：资源加载可能会插队，如前线程执行需要3h后只需3s这样就会让后方先执行</p><p>默认锁为非公平</p></blockquote><blockquote><p>案例说明</p><ol><li><p>生产者和消费者（虚假唤醒）—&gt;juc.lock.TestScene—multipart.lock.TestScene</p></li><li><p>单例模式—饿汉式—懒汉式DCL—&gt;single</p></li><li><p>死锁</p></li></ol></blockquote><blockquote><p>进阶锁</p><ol><li>自旋锁：理解为当有线程拿到锁后，另一条线程想要获取只能一直while等待—&gt;juc.lock.SpinLock</li><li>可重入锁：在拿到一个对象的锁后再去获取另一锁依次类推，类似于递归—&gt;</li><li>读写锁—&gt;juc.lock.TestReadWriteLock</li></ol></blockquote><h2 id="三、集合的安全性"><a href="#三、集合的安全性" class="headerlink" title="三、集合的安全性"></a>三、集合的安全性</h2><blockquote><p>在多线程的情况下，集合LIST—SET—MAP 默认的创造都不具有安全，怎么解决？</p><pre><code class="hljs java"><span class="hljs-number">1</span>.<span class="hljs-comment">//使用jdk提供自带 安全  原理：枷锁 效率低</span>List&lt;String&gt; vector = <span class="hljs-keyword">new</span> Vector&lt;&gt;();<span class="hljs-number">2</span>.<span class="hljs-comment">//使用工具Coclltions类 原理如同上</span>List&lt;String&gt;  list  =  Collections.synchronizedList(<span class="hljs-keyword">new</span>  ArrayList&lt;&gt;());<span class="hljs-number">3</span>. <span class="hljs-comment">//安全 原理：见明知意_读写分离_在多线程同时写入时先将原容器制定一个新容器，然后再写入原容器（不用枷锁，效率高，）</span>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;String&gt; list2 = <span class="hljs-keyword">new</span> CopyOnWriteArrayList&lt;&gt;();   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; set = <span class="hljs-keyword">new</span> CopyOnWriteArraySet&lt;&gt;();   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Object&gt; map = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();</code></pre></blockquote><h2 id="四、Callable"><a href="#四、Callable" class="headerlink" title="四、Callable"></a>四、Callable</h2><blockquote><p>Callable –&gt;区别Runnable</p></blockquote><ol><li>Callable 可以返回值，能抛出被检查的异常。</li><li>基于Runnable的实例化类(FutureTask)适配器进行实现</li><li>有缓存，执行效率高</li></ol><p><img src="https://imgkr.cn-bj.ufileos.com/d155ad55-31e7-4832-a3cc-8c2fdcfcddf4.png" srcset="/img/loading.gif" alt="流程图"></p><blockquote><p>使用</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCallable</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> FutureTask&lt;&gt;(<span class="hljs-keyword">new</span> MyThread());<span class="hljs-comment">//创建适配器</span>        <span class="hljs-comment">//lambad 方式</span>        <span class="hljs-comment">//FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;&gt;(()-&gt;&#123;return 1;&#125;);//创建适配器</span>        <span class="hljs-keyword">new</span> Thread(futureTask).start();        <span class="hljs-comment">//获取执行的返回值</span>        Integer integer = (Integer) futureTask.get(); <span class="hljs-comment">//这个get  方法可能会产生阻塞！把他放到 最后</span>        System.out.println(integer);    &#125;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;        System.out.println(<span class="hljs-string">"执行"</span>);        <span class="hljs-keyword">return</span> <span class="hljs-number">1024</span>;    &#125;&#125;</code></pre><h2 id="五、常用辅助类（必会）"><a href="#五、常用辅助类（必会）" class="headerlink" title="五、常用辅助类（必会）"></a>五、常用辅助类（必会）</h2><blockquote><p>一、CountDownLatch 计数器</p></blockquote> <pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * CountDownLatch ：使用案例--&gt; 当（计数器）数达到某个特定数量的时候，那么会执行任务，否则进行阻塞等待</span><span class="hljs-comment">     * countDownLatch.countDown();//计数器数量减1</span><span class="hljs-comment">     * countDownLatch.await();//等待计数器归零，然后再向下执行</span><span class="hljs-comment">     */</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCountDiwnLatch</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;        <span class="hljs-comment">//当线程数为5时那么执行后面的任务,如果没有达成，那么会进行——阻塞等待</span>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">5</span>);        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5</span> ; i++) &#123;            <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;                System.out.println(<span class="hljs-string">"线程数到达"</span>);                countDownLatch.countDown();<span class="hljs-comment">//数量-1</span>            &#125;).start();        &#125;        countDownLatch.await();<span class="hljs-comment">//等待计数器归零，然后再向下执行</span>        System.out.println(<span class="hljs-string">"Close"</span>);    &#125;</code></pre><blockquote><p>二、CyclicBarrier  线程计数器</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * CyclicBarrier:</span><span class="hljs-comment">    *  使用案例--&gt; 当（线程数）达到某个特定数量的时候，那么会执行一个run 任务，否则进行阻塞等待</span><span class="hljs-comment">    *  每创建一个线程就换判断一次</span><span class="hljs-comment">    *</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCyclicBarrier</span><span class="hljs-params">()</span>  </span>&#123;       CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">5</span>,()-&gt;&#123;System.out.println(<span class="hljs-string">"线程达到数量，执行了"</span>);&#125;);       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">5</span> ; i++) &#123;           <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;               System.out.println(<span class="hljs-string">"测试CyclicBarrier--&gt;新增线程"</span>);               <span class="hljs-keyword">try</span> &#123;                   cyclicBarrier.await();<span class="hljs-comment">//当没有达到线程数时，阻塞等待</span>               &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;                   e.printStackTrace();               &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException e) &#123;                   e.printStackTrace();               &#125;           &#125;).start();       &#125;   &#125;</code></pre><blockquote><p>三、Semaphore 阻塞队列</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">    * Semaphore:阻塞队列</span><span class="hljs-comment">    *  new Semaphore(5)设置最大线程数</span><span class="hljs-comment">    *  semaphore.acquire();//拿到队列位置 相当于拿到锁</span><span class="hljs-comment">    *  semaphore.release();//释放队列资源 相当于释放锁,并唤醒等待的线程</span><span class="hljs-comment">    */</span>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSemaphore</span><span class="hljs-params">()</span></span>&#123;       Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">5</span>);<span class="hljs-comment">//定义队列最大线程5</span>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">10</span> ; i++) &#123;           <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;               <span class="hljs-keyword">try</span> &#123;                   semaphore.acquire();<span class="hljs-comment">//拿到队列位置 相当于拿到锁</span>                   System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"拿到了锁"</span>);                   TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);               &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                   e.printStackTrace();               &#125;<span class="hljs-keyword">finally</span> &#123;                   System.out.println(Thread.currentThread().getName()+<span class="hljs-string">"释放了锁"</span>);                   semaphore.release();<span class="hljs-comment">//释放锁</span>               &#125;           &#125;).start();       &#125;   &#125;</code></pre><h2 id="六、阻塞队列"><a href="#六、阻塞队列" class="headerlink" title="六、阻塞队列"></a>六、阻塞队列</h2><p>什么情况下我们会使用 阻塞队列：多线程并发处理，线程池！</p><blockquote><p>四组API</p></blockquote><table><thead><tr><th>方式</th><th>抛出异常</th><th>有返回值，不抛出异常</th><th>阻塞 等待</th><th>超时等待</th></tr></thead><tbody><tr><td>添加</td><td>add</td><td>oﬀer()</td><td>put()</td><td>oﬀer(,,)</td></tr><tr><td>移除</td><td>remove</td><td>poll()</td><td>take()</td><td>poll(,)</td></tr><tr><td>检测队首元素</td><td>element</td><td>peek</td><td>-</td><td>-</td></tr></tbody></table><p><img src="https://imgkr.cn-bj.ufileos.com/1b4b0fa6-a2ed-46bd-857f-a881f2ad5b49.png" srcset="/img/loading.gif" alt="集合图"></p><blockquote><p>使用BlockKingQueue 子类 详情看jdk’1.8 API文档</p></blockquote><h2 id="七、线程池-重要"><a href="#七、线程池-重要" class="headerlink" title="七、线程池(重要)"></a>七、线程池(重要)</h2><blockquote><p>什么是线程池？</p></blockquote><ol><li>因为创建线程时需要耗费时间和内存，所以存在了线程池</li><li>线程池是提前将线程资源创建好，如果要使用那么会直接来获取，如果使用完后会归还</li><li>提高了性能，时间，减少了内存的损耗</li></ol><blockquote><p>阿里巴巴官方手册不推荐使用工具类Executors工具类穿件 —&gt;pool.TestUtilPool (了解)</p></blockquote><pre><code>1. 因为使用工具类创建可能会导致OOM</code></pre><blockquote><p>使用原生创建（重要）</p><p>7大参数</p><p>四大拒绝策略</p><p>理解 默认开启线程池是2个线程 当沾满时会在 阻塞队列中等待,如果阻塞队列满载时，会启用最大线程池</p><p>Runtime.getRuntime().availableProcessors();//获取当前cpu最大线程数（不要写固定值，要根据自己cpu来填写）</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 解析底层创建线程池</span><span class="hljs-comment"> *  7大参数</span><span class="hljs-comment"> *      new ThreadPoolExecutor(</span><span class="hljs-comment"> *                         2,//默认开启线程池</span><span class="hljs-comment"> *                         5,//最大线程池</span><span class="hljs-comment"> *                         5,//超时没有调用释放线程</span><span class="hljs-comment"> *                         TimeUnit.SECONDS,//时长单位</span><span class="hljs-comment"> *                         new ArrayBlockingQueue&lt;&gt;(2), //阻塞队列</span><span class="hljs-comment"> *                         Executors.defaultThreadFactory(),//工厂</span><span class="hljs-comment"> *                         new ThreadPoolExecutor.AbortPolicy()//拒绝策略</span><span class="hljs-comment"> *                 );</span><span class="hljs-comment"> *  4大拒绝策略</span><span class="hljs-comment"> *   new ThreadPoolExecutor.AbortPolicy() //当线程数超过线程池的最大时，那么抛出异常</span><span class="hljs-comment"> *   new ThreadPoolExecutor.CallerRunsPolicy()//当线程数超过线程池的最大时,哪里来回到哪里 将由调用此线程的线程执行，回调</span><span class="hljs-comment"> *   new ThreadPoolExecutor.DiscardPolicy()//线程池满了 那么就丢掉不执行</span><span class="hljs-comment"> *   new ThreadPoolExecutor.DiscardPolicy()//线程池满了 ，不报错，等待 尝试去抢第一个执行的线程，如果时间超过等待时长丢掉</span><span class="hljs-comment"> * 实例来理解</span><span class="hljs-comment"> *  ：理解 默认线程池是2个线程 当沾满时会在 阻塞队列中等待,如果阻塞队列满载时，会启用最大线程池</span><span class="hljs-comment"> *</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestThreadPoolExecutor</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        <span class="hljs-keyword">int</span> max = Runtime.getRuntime().availableProcessors();<span class="hljs-comment">//获取当前cpu最大线程数（）</span>        System.out.println(max);        ThreadPoolExecutor threadPoolExecutor =                <span class="hljs-keyword">new</span> ThreadPoolExecutor(                        <span class="hljs-number">2</span>,<span class="hljs-comment">//默认开启线程池</span>                        max,<span class="hljs-comment">//最大线程池</span>                        <span class="hljs-number">2</span>,<span class="hljs-comment">//超时没有调用释放线程</span>                        TimeUnit.SECONDS,<span class="hljs-comment">//阻塞时长单位</span>                        <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="hljs-number">3</span>), <span class="hljs-comment">//阻塞队列</span>                        Executors.defaultThreadFactory(),<span class="hljs-comment">//默认工厂</span>                        <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardOldestPolicy()<span class="hljs-comment">//拒绝策略</span>                );        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">15</span> ; i++) &#123;            threadPoolExecutor.execute(()-&gt;&#123;                <span class="hljs-keyword">try</span> &#123;                    System.out.println(<span class="hljs-string">"创建"</span>+Thread.currentThread().getName());                    TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;                    System.out.println(e.getMessage());                &#125;<span class="hljs-keyword">finally</span> &#123;                    threadPoolExecutor.shutdown();                    <span class="hljs-comment">//System.out.println("释放了"+Thread.currentThread().getName());</span>                &#125;            &#125;);        &#125;    &#125;&#125;</code></pre><h2 id="八、Stream"><a href="#八、Stream" class="headerlink" title="八、Stream"></a>八、Stream</h2><blockquote><p>什么是Stream</p></blockquote><ol><li>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</li><li>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</li></ol><blockquote><p>使用 —&gt;更多使用查看jdk文档</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> *题目要求：一分钟内完成此题，只能用一行代码实现！</span><span class="hljs-comment"> *现在有5个用户！筛选：</span><span class="hljs-comment"> *1、ID  必须是偶数</span><span class="hljs-comment"> *2、年龄必须大于23岁</span><span class="hljs-comment"> *3、用户名转为大写字母</span><span class="hljs-comment"> *4、用户名字母倒着排序</span><span class="hljs-comment"> *5、只输出一个用户！</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestStream</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        List&lt;User&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();        list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"A"</span>,<span class="hljs-number">20</span>,<span class="hljs-number">10</span>));        list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"B"</span>,<span class="hljs-number">25</span>,<span class="hljs-number">8</span>));        list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"C"</span>,<span class="hljs-number">26</span>,<span class="hljs-number">7</span>));        list.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">"D"</span>,<span class="hljs-number">30</span>,<span class="hljs-number">5</span>));        list.stream()                .filter((u)-&gt;&#123;<span class="hljs-keyword">return</span> u.getId()%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>; &#125;)<span class="hljs-comment">//过滤</span>                .filter((u)-&gt;u.getAge()&gt;<span class="hljs-number">23</span>)<span class="hljs-comment">//过滤率</span>                .map((t)-&gt;&#123;<span class="hljs-keyword">return</span> t.getName().toUpperCase();&#125;)<span class="hljs-comment">//根据条件转换大写后，映射</span>                .sorted((t1,t2)-&gt;&#123;<span class="hljs-keyword">return</span> t1.compareTo(t2);&#125;)<span class="hljs-comment">//进行比较</span>                .limit(<span class="hljs-number">1</span>)<span class="hljs-comment">//限流</span>                .forEach(System.out::println);<span class="hljs-comment">//输出</span>        ;    &#125;&#125;</code></pre><h2 id="九、ForkJoin"><a href="#九、ForkJoin" class="headerlink" title="九、ForkJoin"></a>九、ForkJoin</h2><blockquote><p>ForkJoin</p><ul><li>在大数据的访问运作下，比较明显 如果小数据可以不需要</li><li>思想：</li><li>1.运行时会将任务划分为多个模块去执行，提高效率</li><li>2.在执行时是双端队列，线程之间可以工作窃取，可以更高效的完成任务</li><li>具体查看文档</li></ul></blockquote><h2 id="十、volatile（重要）"><a href="#十、volatile（重要）" class="headerlink" title="十、volatile（重要）"></a>十、volatile（重要）</h2><blockquote><p>请你谈谈你对 Volatile 的理解</p></blockquote><p>​    Volatile 是 Java 虚拟机提供轻量级的同步机制</p><p>​    1、保证可见性</p><p>​    2、不保证原子性</p><p>​    3、禁止指令重排(因为有cpu内存屏障，所有禁止指令重排)</p><p>​    </p><blockquote><p>可见性</p></blockquote><p><code>:在多线程中开辟新的线程，会进行划分一个新的线程工作区内存，内存需要调用主存中的数据，当某个线程在调用时会及时（实时）的读取主存中的数据，并且在释放锁后及时的更新数据，防止并发其他线程拿到脏数据</code></p><blockquote><p>禁止指令重排</p></blockquote><p><code>指令重排：java程序在运行时需要转换为字节码运行，字节码再转换为电脑语令运行，所以在运行时不一定是按照代码的上下顺序来执行的</code></p><blockquote><p>原子性</p></blockquote><p><code>:执行一个操作时，要么成功，要么不成功，原子性就包含了禁止指令重排</code></p><p>因为volatile非原子性，那么就要保证原子性，所以使用</p><ul><li>java.util.concurrent.atomic  中提供好的类—&gt;具体查看源码+api</li></ul><h2 id="十一、深入理解CAS"><a href="#十一、深入理解CAS" class="headerlink" title="十一、深入理解CAS"></a>十一、深入理解CAS</h2><blockquote><p>什么是CAS?</p></blockquote><p> 在计算机科学中，比较和交换（Conmpare And Swap）是用于实现多线程(同步)的原子指令。</p><p>CAS也就是底层同步的原理</p><p>CAS ： 比较当前工作内存中的值和主内存中的值，如果这个值是期望的，那么则执行操作！如果不是就一直循环（自旋锁）！</p><p>缺点：</p><p>1、 循环会耗时</p><p>2、一次性只能保证一个共享变量的原子性</p><p>3、ABA问题</p><blockquote><p>代码举例说明ABA问题（相对于乐观锁）（狸猫换太子）</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 实例说明CAS</span><span class="hljs-comment"> *   也就是说：在运行过程中可能有其他线程对某条数据对其作出了改变，</span><span class="hljs-comment"> *              但是最终我想要获取的是最初的那个版本的值（这就出现了ABA问题）</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestCAS</span> </span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        test();        test2();    &#125;    <span class="hljs-comment">//没有解决ABA问题</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        AtomicReference&lt;Integer&gt; objectAtomicReference = <span class="hljs-keyword">new</span> AtomicReference&lt;&gt;(<span class="hljs-number">10</span>);        <span class="hljs-comment">//捣乱的线程</span>        objectAtomicReference.compareAndSet(<span class="hljs-number">10</span>,<span class="hljs-number">15</span>);        objectAtomicReference.compareAndSet(<span class="hljs-number">15</span>,<span class="hljs-number">11</span>);        <span class="hljs-keyword">boolean</span> b = objectAtomicReference.compareAndSet(<span class="hljs-number">11</span>, <span class="hljs-number">15</span>);<span class="hljs-comment">//达到预期值进行替换改变</span>        System.out.println(b);    &#125;    <span class="hljs-comment">//解决ABA问题 添加版本号 使用原子类</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        AtomicStampedReference&lt;Integer&gt; objectAtomicStampedReference =                <span class="hljs-keyword">new</span> AtomicStampedReference&lt;&gt;(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>);<span class="hljs-comment">//初始值，版本号</span>        <span class="hljs-keyword">int</span> stamp = objectAtomicStampedReference.getStamp();<span class="hljs-comment">//获取版本号</span>        <span class="hljs-comment">//达到预期进行替换改变（预期值，改变值，预期号，新的号）</span>        objectAtomicStampedReference.compareAndSet(<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,objectAtomicStampedReference.getStamp(),objectAtomicStampedReference.getStamp()+<span class="hljs-number">1</span>);        objectAtomicStampedReference.compareAndSet(<span class="hljs-number">15</span>,<span class="hljs-number">10</span>,objectAtomicStampedReference.getStamp(),objectAtomicStampedReference.getStamp()+<span class="hljs-number">1</span>);        <span class="hljs-keyword">boolean</span> b = objectAtomicStampedReference.compareAndSet(<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, stamp, objectAtomicStampedReference.getStamp() + <span class="hljs-number">1</span>);        System.out.println(b);    &#125;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2020/06/15/Docker/"/>
    <url>/2020/06/15/Docker/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、docker基本语句"><a href="#一、docker基本语句" class="headerlink" title="一、docker基本语句"></a>一、docker基本语句</h2><ul><li><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">启动docker服务:</span>systemctl start docker <span class="hljs-meta">#</span><span class="bash">l停止docker服务:</span>systemctl stop docker <span class="hljs-meta">#</span><span class="bash">重启docker服务:</span>systemctl restart docker<span class="hljs-meta">#</span><span class="bash">查看docker服务状态:</span>systemctl status docker <span class="hljs-meta">#</span><span class="bash">设置开机启动docker服务:</span>systemctl enable docker</code></pre></li><li><p>镜像相关</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看本地所有的镜像</span>docker images<span class="hljs-meta">#</span><span class="bash"> 查看所用镜像的id</span>docker images –q <span class="hljs-meta">#</span><span class="bash">搜索镜像:从网络中查找需要的镜像</span>docker search 镜像名称<span class="hljs-meta">#</span><span class="bash">拉取镜像:从Docker仓库下载镜像到本地</span>docker pull 镜像名称<span class="hljs-meta">#</span><span class="bash">删除镜像: 删除本地镜像</span>docker rmi 镜像id docker rmi `docker images -q`  # 删除所有本地镜像</code></pre></li><li><p>容器相关</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看容器</span>docker ps <span class="hljs-meta">#</span><span class="bash"> 查看所有容器</span>docker ps –a <span class="hljs-meta">#</span><span class="bash">创建并启动容器</span>docker run 参数 <span class="hljs-meta">#</span><span class="bash">进入容器</span>docker exec 参数 # 退出容器，容器不会关闭<span class="hljs-meta">#</span><span class="bash">停止容器</span>docker stop 容器名称<span class="hljs-meta">#</span><span class="bash">启动容器</span>docker start 容器名称<span class="hljs-meta">#</span><span class="bash">删除容器</span>docker rm 容器名称<span class="hljs-meta">#</span><span class="bash">查看容器信息</span>docker inspect 容器名称</code></pre><p>参数说明：</p><p>•    -i：保持容器运行。通常与 -t 同时使用。加入it这两个参数后，容器创建后自动进入容器中，退出容器后，容器自动关闭。</p><p>•    -t：为容器重新分配一个伪输入终端，通常与 -i 同时使用。</p><p>•    -d：以守护（后台）模式运行容器。创建一个容器在后台运行，需要使用docker exec 进入容器。退出后，容器不会关闭。</p><p>•    -it 创建的容器一般称为交互式容器，-id 创建的容器一般称为守护式容器</p><p>•    –name：为创建的容器命名。</p></li></ul><hr><h2 id="二、docker安装"><a href="#二、docker安装" class="headerlink" title="二、docker安装"></a>二、docker安装</h2><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、yum 包更新到最新 </span>yum update<span class="hljs-meta">#</span><span class="bash"> 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的 </span>yum install -y yum-utils device-mapper-persistent-data lvm2<span class="hljs-meta">#</span><span class="bash"> 3、 设置yum源</span>yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 4、 安装docker，出现输入的界面都按 y </span>yum install -y docker-ce<span class="hljs-meta">#</span><span class="bash"> 出错看下</span><span class="hljs-meta">#</span><span class="bash"> 5、 查看docker版本，验证是否验证成功</span>docker -v<span class="hljs-meta">#</span><span class="bash"> 6、 配置阿里云仓库镜像</span>sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'&#123;  "registry-mirrors": ["https://ltj0xunu.mirror.aliyuncs.com"]&#125;EOFsudo systemctl daemon-reloadsudo systemctl restart docker</code></pre><p><strong>4）如果出错没有可用软件包 docker-ce。</strong></p><pre><code class="hljs shell">解决办法：1.yum添加软件源sudo yum-config-manager \    --add-repo \    https://mirrors.ustc.edu.cn/docker-ce/linux/centos/docker-ce.repo    2.然后刷新缓存    sudo yum makecache fast    3.然后安装docker-ce    sudo yum install docker-ce</code></pre><hr><h2 id="三、应用部署"><a href="#三、应用部署" class="headerlink" title="三、应用部署"></a>三、应用部署</h2><p>参考文件应用部署</p><h2 id="四、容器数据卷概念"><a href="#四、容器数据卷概念" class="headerlink" title="四、容器数据卷概念"></a>四、容器数据卷概念</h2><p>•    数据卷是宿主机(linux)中的一个目录或文件</p><p>•    当容器目录和数据卷目录绑定后，对方的修改会立即同步</p><p>•    一个数据卷可以被多个容器同时挂载</p><p>•    一个容器也可以被挂载多个数据卷</p><p><strong>数据卷作用</strong></p><p>​    • 容器数据持久化</p><p>​    • 外部机器和容器间接通信</p><p>​    • 容器之间数据交换</p><blockquote><p>补充</p></blockquote><p><code>目录挂载是将宿主机中的文件和容器中的文件同步</code></p><blockquote><p>复制容器中的文件到宿主机中</p></blockquote><p>docker cp 容器id:容器内文件路径 目标路径</p><p><code>docker cp 2a580f7d2308:/etc/nginx/nginx.conf ~/nginx/</code></p><blockquote><p>进入容器直接修改配置</p></blockquote><pre><code class="hljs shell">会发现vi或者vim命令没有用，解决办法：apt-get  update  完成之后 apt-get install vim</code></pre><p>挂载实例：</p><pre><code class="hljs shell">docker run -id \-p 3306:3306 \--name=c_mysql \-v $PWD/conf:/etc/mysql/conf.d \-v $PWD/logs:/logs \-v $PWD/data:/var/lib/mysql \-e MYSQL_ROOT_PASSWORD=123456 \<span class="hljs-meta">#</span><span class="bash">启动容器的镜像 如果没有会自动下载</span>mysql</code></pre><p>参数说明：</p><ul><li><strong>-p 3307:3306</strong>：将容器的 3306 端口映射到宿主机的 3307 端口。</li><li><strong>-v $PWD/conf:/etc/mysql/conf.d</strong>：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。配置目录</li><li><strong>-v $PWD/logs:/logs</strong>：将主机当前目录下的 logs 目录挂载到容器的 /logs。日志目录</li><li><strong>-v $PWD/data:/var/lib/mysql</strong> ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。数据目录</li><li><strong>-e MYSQL_ROOT_PASSWORD=123456：</strong>初始化 root 用户的密码。</li></ul><p>$PWD:引用当前目录</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看容器的目录方便挂载</span>docker exec –it c_mysql /bin/bash</code></pre><p>​        </p><hr><h2 id="五、dockerFile"><a href="#五、dockerFile" class="headerlink" title="五、dockerFile"></a>五、dockerFile</h2><p>创建镜像—部署springboot项目</p><ol><li><p>创建file文件–root目录下</p><pre><code class="hljs shell">vim dockerfile #文件名随意<span class="hljs-meta">#</span><span class="bash">添加内容</span>FROM java:8  #from 依赖的环境MAINTAINER  xincen &lt;xincen.cn&gt; # 添加注明作者信息<span class="hljs-meta">#</span><span class="bash">项目名  生成名</span>CMD java -jar springboot-shiro.jar app.jar #运行项目</code></pre></li><li><p>构建dockerfile—构建镜像</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">docker build –f dockerfile文件路径 –t 镜像名称:版本</span>docker build -f dockerfile -t app:1.0</code></pre></li></ol><hr><h2 id="六、Docker-Compose"><a href="#六、Docker-Compose" class="headerlink" title="六、Docker Compose"></a>六、Docker Compose</h2><h3 id="一、安装Docker-Compose"><a href="#一、安装Docker-Compose" class="headerlink" title="一、安装Docker Compose"></a>一、安装Docker Compose</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Compose目前已经完全支持Linux、Mac OS和Windows，在我们安装Compose之前，需要先安装Docker。下面我 们以编译好的二进制包方式安装在Linux系统中。 </span>curl -L https://github.com/docker/compose/releases/download/1.22.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose<span class="hljs-meta">#</span><span class="bash"> 设置文件可执行权限 </span>chmod +x /usr/local/bin/docker-compose<span class="hljs-meta">#</span><span class="bash"> 查看版本信息 </span>docker-compose -version</code></pre><h3 id="二、卸载Docker-Compose"><a href="#二、卸载Docker-Compose" class="headerlink" title="二、卸载Docker Compose"></a>二、卸载Docker Compose</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 二进制包方式安装的，删除二进制文件即可</span>rm /usr/local/bin/docker-compose</code></pre><h3 id="三、-使用docker-compose编排nginx-springboot项目"><a href="#三、-使用docker-compose编排nginx-springboot项目" class="headerlink" title="三、 使用docker compose编排nginx+springboot项目"></a>三、 使用docker compose编排nginx+springboot项目</h3><ol><li>创建docker-compose目录</li></ol><pre><code class="hljs shell">mkdir ~/docker-composecd ~/docker-compose</code></pre><ol start="2"><li>编写 docker-compose.yml 文件</li></ol><pre><code class="hljs shell">version: '3'services:  nginx:   image: nginx   ports:    - 80:80   links:    - app   volumes:    - ./nginx/conf.d:/etc/nginx/conf.d  app:    image: app    expose:      - "8080"</code></pre><ol start="3"><li>创建./nginx/conf.d目录</li></ol><pre><code class="hljs shell">mkdir -p ./nginx/conf.d</code></pre><ol start="4"><li>在./nginx/conf.d目录下 编写itheima.conf文件</li></ol><pre><code class="hljs shell">server &#123;    listen 80;    access_log off;    location / &#123;        proxy_pass http://app:8080;    &#125;   &#125;</code></pre><ol start="5"><li>在~/docker-compose 目录下 使用docker-compose 启动容器</li></ol><pre><code class="hljs shell">docker-compose up</code></pre><ol start="6"><li>测试访问</li></ol><pre><code class="hljs shell">http://192.168.149.135/hello</code></pre><hr><h2 id="七、Doker私有化仓库"><a href="#七、Doker私有化仓库" class="headerlink" title="七、Doker私有化仓库"></a>七、Doker私有化仓库</h2><h3 id="一、私有仓库搭建"><a href="#一、私有仓库搭建" class="headerlink" title="一、私有仓库搭建"></a>一、私有仓库搭建</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、拉取私有仓库镜像 </span>docker pull registry<span class="hljs-meta">#</span><span class="bash"> 2、启动私有仓库容器 </span>docker run -id --name=registry -p 5000:5000 registry<span class="hljs-meta">#</span><span class="bash"> 3、打开浏览器 输入地址http://私有仓库服务器ip:5000/v2/_catalog，看到&#123;<span class="hljs-string">"repositories"</span>:[]&#125; 表示私有仓库 搭建成功</span><span class="hljs-meta">#</span><span class="bash"> 4、修改daemon.json   </span>vim /etc/docker/daemon.json    <span class="hljs-meta">#</span><span class="bash"> 在上述文件中添加一个key，保存退出。此步用于让 docker 信任私有仓库地址；注意将私有仓库服务器ip修改为自己私有仓库服务器真实ip </span>&#123;"insecure-registries":["私有仓库服务器ip:5000"]&#125; <span class="hljs-meta">#</span><span class="bash"> 5、重启docker 服务 </span>systemctl restart dockerdocker start registry</code></pre><h3 id="二、将镜像上传至私有仓库"><a href="#二、将镜像上传至私有仓库" class="headerlink" title="二、将镜像上传至私有仓库"></a>二、将镜像上传至私有仓库</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 1、标记镜像为私有仓库的镜像     </span>docker tag centos:7 私有仓库服务器IP:5000/centos:7 <span class="hljs-meta">#</span><span class="bash"> 2、上传标记的镜像     </span>docker push 私有仓库服务器IP:5000/centos:7</code></pre><h3 id="三、-从私有仓库拉取镜像"><a href="#三、-从私有仓库拉取镜像" class="headerlink" title="三、 从私有仓库拉取镜像"></a>三、 从私有仓库拉取镜像</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">拉取镜像 </span>docker pull 私有仓库服务器ip:5000/centos:7</code></pre>]]></content>
    
    
    <categories>
      
      <category>运维</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>底层分析String</title>
    <link href="/2020/06/15/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90String/"/>
    <url>/2020/06/15/%E5%BA%95%E5%B1%82%E5%88%86%E6%9E%90String/</url>
    
    <content type="html"><![CDATA[<h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><blockquote><p>特性</p></blockquote><ol><li>不可变性：不可变性也就是 如果创建了一个String对象，进行改变那么就是再创建了一个对象，而不是在原有的改变。</li><li>jdk8之前内部存储定义的是char类型数组</li><li>jdk9以后是定义的byte类型数组存储，可以更好的节省了空间。</li><li>字符串常量池在jdk1.7（含7）以后都是存储在堆空间中的。</li></ol><blockquote><p>字符串常量池</p></blockquote><ol><li>String pool 底层也就是HashTable </li><li>所以字符串常量池是不可重复的</li><li>如 String s = “abc” s2 =”abc”. 在栈中其实引用的是同一个地址（编译优化）</li><li>jdk1.6以前 HashTable 长度默认值1009 ，jdk7默认为 60013， jdk8以后设置长度最低要求1009</li></ol><blockquote><p>参数设置</p></blockquote><p>-XX:StringTableSize=*  </p><p><code>链表短的话会影响效率</code></p><blockquote><p>实战</p></blockquote><p>可编译看字节码，一下都是基于jdk1.8以后进行说明</p><p><code>声明:1.字面量创建String 那么会在字符串常量池中添加一个空间，但是堆空间不会有地址；</code></p><p><code>声明:2.new 方式创建String 那么会在字符串常量池中添加一个空间，并且在堆中开辟一个空间，并且引用堆空间的地址</code></p><p><code>声明:3.两个字面量拼接，那么会编译阶段就会进行编译优化如String c = &quot;a&quot;+&quot;b&quot;;编译期间会默认为String c = &quot;ab&quot;,不会再字符串常量池中分别开辟空间</code></p><p><code>声明:4.在String c = new String(&quot;a&quot;)+new String(&quot;b&quot;)相加是不会在字符串常量池中开辟新的空间的，c只是引用</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        String s = <span class="hljs-string">"javaHeap"</span>;        String s1 = <span class="hljs-string">"java"</span>;        String s2 = <span class="hljs-string">"heap"</span>;        String s3 = s1 + s2;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 因为编译时 s1 s2 相当于在字符串常量池中创建对象，不知道其中的值，需要引用地址</span><span class="hljs-comment">         * 当赋值时，那么底层会使用 StringBuilder 的append 方法进行拼接，是引用了两个地址，进行赋值,组成新的对象,并且字符串常量池中是没有"a、javaHeap"</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">boolean</span> result = s == s3; <span class="hljs-comment">//false</span>    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        String s = <span class="hljs-string">"javaHeap"</span>;        <span class="hljs-keyword">final</span> String s1 = <span class="hljs-string">"java"</span>;        <span class="hljs-keyword">final</span> String s2 = <span class="hljs-string">"heap"</span>;        String s3 = s1 + s2;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  final在编译期就已经确定下来了值，在进行字符串拼接时会进行 编译优化 String s3 = "javaHeap"</span><span class="hljs-comment">         */</span>        <span class="hljs-keyword">boolean</span> result = s == s3; <span class="hljs-comment">//true</span>    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span>&#123;        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"javaHeap"</span>);        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 在内存中创建了5个对象 细致的说6个</span><span class="hljs-comment">         * 1.new 在堆中</span><span class="hljs-comment">         * 2.“字符串”在字符串常量池中</span><span class="hljs-comment">         * 3. + 变量拼接 创建了StringBuilder</span><span class="hljs-comment">         * 外加：StringBuilder 中的toString方法，底层也就是new String();但是不会在常量池中创建</span><span class="hljs-comment">         */</span>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"java"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Heap"</span>);    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         * 字面量和new 的区别</span><span class="hljs-comment">         * 1. 字面量会在字符串常量池中 放入，new对象也会在常量池中放入"javaHeap"</span><span class="hljs-comment">         * 2. 字面量不会在堆中开辟空间，而new会在堆中开辟空间</span><span class="hljs-comment">         */</span>        String b = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"javaHeap"</span>);<span class="hljs-comment">//返回的是堆空间中的地址</span>        String a = <span class="hljs-string">"javaHeap"</span>;        System.out.println(a==b);<span class="hljs-comment">//false</span>    &#125;</code></pre><h2 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h2><blockquote><p>简介</p></blockquote><p><code>Intern方法：查看字符串常量池中是否有 ， 如果有，那么返回字符串常量池中的引用，如果没有将会查看堆中是否有数据，有将会引用对象地址，没有那么创建字符串，放入常量池。</code></p><blockquote><p>为什么使用intern？</p></blockquote><p>:降低内存的大小，提高的运行的速度，会自动释放内存，会引用常量池中的数据</p><blockquote><p>实战详解</p></blockquote><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  内存结构详解：</span><span class="hljs-comment">         *      new String 是在堆中创建了对象，并且在字符串常量池中创建了字面量，</span><span class="hljs-comment">         *      第二行：（在创建字面量时 先查看了堆中是否有对象的引用，如果有那么就不会进行创建，之间在字符串常量池中引用了堆中的地址【节省空间】）</span><span class="hljs-comment">         *      String s = "javaHeap";</span><span class="hljs-comment">         *      字面量：只会在常量池中 创建常量。</span><span class="hljs-comment">         *</span><span class="hljs-comment">         *      所以在比较时 new 在常量池是对象引用地址，而字面量是值（或者说地址）所以false</span><span class="hljs-comment">         */</span>        String s2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"javaHeap"</span>);        s2.intern();        String s = <span class="hljs-string">"javaHeap"</span>;        System.out.println(s==s2);<span class="hljs-comment">//false</span>    &#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-comment">/**</span><span class="hljs-comment">         *  内存结构详解：</span><span class="hljs-comment">         *      这里在进行第一行代码时 结构（创建了6个对象，最后在堆中生成了对象s ="javaHeap" 变量池中没有生成）</span><span class="hljs-comment">         *        第二行：在变量池中生成</span><span class="hljs-comment">         *        第三行：直接引用变量池</span><span class="hljs-comment">         *</span><span class="hljs-comment">         */</span>        String s = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"java"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"Heap"</span>);        s.intern();        String s2 = <span class="hljs-string">"javaHeap"</span>;        System.out.println(s==s2);<span class="hljs-comment">//true</span>    &#125;<span class="hljs-comment">//-------------------------------------------------------------------------------------------------</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;        String str2 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">"xin"</span>) + <span class="hljs-keyword">new</span> String(<span class="hljs-string">"cen"</span>);        <span class="hljs-comment">//String str2 = new String("a");</span>        String intern = str2.intern();        String str = <span class="hljs-string">"xincen"</span>;        System.out.println(intern==str);<span class="hljs-comment">//true 比较串常量池中的地址</span>        System.out.println(str2==str);<span class="hljs-comment">//false 比较了堆中的地址</span>    &#125;</code></pre><h2 id="面试点提问-源码"><a href="#面试点提问-源码" class="headerlink" title="面试点提问+源码"></a>面试点提问+源码</h2><blockquote><p>问如果在字符串拼接的时候一定是用的StringBuilder么？</p></blockquote><p>答：不是 因为final 修饰的不是</p>]]></content>
    
    
    <categories>
      
      <category>Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深入理解JVM</title>
    <link href="/2020/06/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/"/>
    <url>/2020/06/15/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><blockquote><p>jdk、jre、jvm的关系</p></blockquote><p>JDK：是Java开发工具包，是Sun Microsystems针对Java开发员的产品。<br>JDK中包含JRE，在JDK的安装目录下有一个名为jre的目录，里面有两个文件夹bin和lib，在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。<br>JRE：是java程序的运行环境，它包含JVM。<br>三者的关系：JDK(JRE(JVM))</p><blockquote><p>什么是JVM</p></blockquote><p>可以简单的理解为：就是运行编译好的java文件生成 的.class文件，并且解析为当前运行系统所对应的指令。</p><p><code>1. Java程序的跨平台特性主要是指字节码文件可以在任何具有Java虚拟机的计算机或者电子设备上运行，Java虚拟机中的Java解释器负责将字节码文件解释成为特定的机器码进行运行，</code></p><ol start="2"><li>粗略分来，JVM的内部体系结构分为三部分，分别是：类装载器（ClassLoader）子系统，运行时数据区，和执行引擎。</li></ol><blockquote><p>JVM 的位置在哪里？</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524151928629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>JVM架构图</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524151956292.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="一、类装载子系统"><a href="#一、类装载子系统" class="headerlink" title="一、类装载子系统"></a>一、类装载子系统</h2><p>1.通过一个类的全限定明获取定义此类的二进制字节流；</p><p>2.将这个字节流所代表的的静态存储结构转化为方法区的运行时数据；</p><p>3.在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</p><blockquote><p>类加载器分类</p></blockquote><ol><li>引导类加载器[BootStrapClassLoader]:负责加载 JAVA_HOME\lib 目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如rt.jar）的类。</li><li>扩展类加载器(Extension ClassLoader)：负责加载 JAVA_HOME\lib\ext 目录中的，或通过java.ext.dirs系统变量指定路径中的类库。</li><li>应用程序类加载器(Application ClassLoader)：负责加载用户路径（classpath）上的类库。</li></ol><p>JVM通过双亲委派模型进行类的加载，当然我们也可以通过继承java.lang.ClassLoader实现自定义的类加载器。</p><blockquote><p>链接模块</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524153320429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ol><li><p><strong>验证（Verify）</strong></p><ol><li><p>目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被加载类的正确性，不会危害虚拟机自身安全。</p></li><li><p>主要包括四种验证，文件格式验证，源数据验证，字节码验证，符号引用验证。</p></li></ol></li><li><p><strong>准备（Prepare）</strong></p><ol><li>为类变量分配内存并且设置该类变量的默认初始值，即零值；</li><li>这里不包含用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显式初始化；</li><li>之类不会为实例变量分配初始化，类变量会分配在方法去中，而实例变量是会随着对象一起分配到java堆中。</li></ol></li><li><p><strong>解析（Resolve）</strong></p><ol><li>将常量池内的符号引用转换为直接引用的过程。</li><li>事实上，解析操作网晚会伴随着jvm在执行完初始化之后再执行</li></ol></li></ol><blockquote><p>初始化模块</p></blockquote><ol><li><p>init（构造器初始化）</p><p><code>默认每个类都有</code></p></li><li><p>cinit（静态变量初始化）</p><p><code>当在代码中有静态值，或者静态代码块之类，会自动创建cinit初始化方法</code></p></li></ol><h3 id="①-双亲委派机制（重要）"><a href="#①-双亲委派机制（重要）" class="headerlink" title="①.双亲委派机制（重要）"></a>①.双亲委派机制（重要）</h3><p><img src="https://img-blog.csdnimg.cn/20200525181104945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p> <a href><code>每个类都默认有一个父类Object ，当在加载类时，会自动向上委托，由父类的类加载器进行加载，如果父类还存在其他父类那么会以此类推（类似递归）向上委托，最终由父类的，启动类加载器进行加载，如果父类的加载子系统，不能加载子类，那么就会向下委托，由子类本身加载，这就是双亲委派机制。</code></a></p><p>优点：</p><ol><li><p>避免了重复的加载</p><ol start="2"><li>保护程序的安全，防止API被串改（如手动写java.lang包String类）</li></ol></li></ol><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><blockquote><p>简介</p></blockquote><ol><li>程序计数器也称PC寄存器 （PC Register）</li><li>PC寄存器是用来存储指向下一条指令的地址，也即将要执行的指令代码。由执行引擎读取下一条。</li><li>它是一个很小的空间，几乎可以忽略不计。也是运行速度最快的存储区域。</li></ol><blockquote><p>举例说明：</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200526220317683.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>声明：简要理解也就是因为在运行时CPU需要不停的切换个线程，这时候就需要PC寄存器来记录当前线程运行到哪个位置了，即将运行哪里给记录下来，等待下次切换回后进行调用。</p><h2 id="二、栈"><a href="#二、栈" class="headerlink" title="二、栈"></a>二、栈</h2><blockquote><p>详情结构图</p><p><img src="https://img-blog.csdnimg.cn/20200526214637821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"> </p></blockquote><blockquote><p>虚拟机栈的特点</p></blockquote><ol><li><p>内存小，跨平台性，可以少量存储一些变量，内存地址，用来管理Java方法的调用。</p></li><li><p>栈也就是方法，一个线程就是一个栈，所以说是线程安全的，是线程私有的—&gt;声明周期与线程同步</p></li><li><p>先进后出（执行完就出）栈帧相当于执行方法，调用完就出</p></li><li><p>因为栈比较小，栈不存在GC问题（OOM）</p><p><strong>声明：</strong></p></li></ol><p><code>一个线程就是一个栈 栈中包含栈帧：     栈帧也就是方法---栈帧中包            含变量表--&gt;变量表包含               变量槽Slot（也就是索引）---&gt;double long因为是8个字节64位占用2个Slot 32位一个，按照加载变量的顺序来分配，索引槽，this（静态是没有this变量槽）默认第一个0，只要不是静态默认都有this           操作数栈：在变量进入变量表时都会经过操作数栈           动态链接：引用调用常量池中的数据          方法的调用：静态链接：早期绑定---在编译时就确定了调用的方法，如static final private 修饰的方法       动态链接：晚期绑定：在运行时才确定了方法 比如接口</code></p><blockquote><p>栈异常</p></blockquote><p>StackOverflowError：当栈分配的空间不足时，那么会出现—&gt;通常是递归时</p><blockquote><p>设置栈的大小</p></blockquote><p>-Xss：如-Xss128k</p><blockquote><p>本地方法栈（了解）</p></blockquote><ol><li>本地方法栈也是私有的。</li><li>本地方法栈用于管理本地方法的调用。</li><li>允许被实现成固定或者是可动态扩展的内存大小。</li><li>本地方法是用C语言实现的</li></ol><p>声明：粗略的可以理解为本地方法栈就是使用java可以调用本地方法（C语言编写）简介的操作内存等。</p><hr><hr><h2 id="三、堆"><a href="#三、堆" class="headerlink" title="三、堆"></a>三、堆</h2><p><img src="https://img-blog.csdnimg.cn/20200524152039997.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>简介</p></blockquote><ol><li>堆在运行时数据区占用比较大的一部分</li><li>通常来说new对象都是放在堆中的。</li><li>堆中又分为新生代、老年代。</li><li>内存默认比例分配1:2</li><li>堆中存放字符串常量池（后有详解）</li></ol><blockquote><p>代码简单优化建议</p></blockquote><p><code>开发中能使用局部变量的，就不要使用全局</code></p><h3 id="①新生代"><a href="#①新生代" class="headerlink" title="①新生代"></a>①新生代</h3><blockquote><p>简介</p></blockquote><ol><li>新生代使用了复制算法</li><li>新生代为gc的重点对象，经官方测试70%对象都生命周期都会在新生代中完结</li><li>新生代又分为了eden、survivor1、survivor2</li><li>内存比例分默认为：8:1:1；j8默认开通自适配比例可能有所变化6:2:2</li><li>新生代收集器：Minor GC/Young GC</li></ol><blockquote><p>eden(新生区)</p></blockquote><pre><code>当初始加载对象时会进入新生区</code></pre><blockquote><p>survivor（幸存区）</p></blockquote><ol><li><p>幸存区又分为from 和 to —谁为空谁为to ，始终都会有一个区域为空。</p><ol start="2"><li><p>幸存区不会主动进行垃圾回收，只会eden回收时才会附带进行gc</p></li><li><p>当在幸存区中的阈值达到了15后（默认15可修改）会自动进入老年代</p><p>当新生区（eden）出现了内存不足时，会进行YGC，那么会将没有指针的对象回收，还有指针引向的对象放入survivor1或者survivor2区域中，eden清空，数据放入一个survivor中。—当第二次进行gc那么会将eden数据放入另一个空的survivor中，并且将当前survivor中有效数据，放入空的survivor中，一次类推。</p></li></ol></li></ol><blockquote><p>TLAB(快速分配策略)</p></blockquote><pre><code>由于堆中的空间都是共享的，所以存在线程安全的问题，这时候就出现了TLAB缓冲区的线程私有的 TLAB ，保证了安全性，是在eden 中只占1%内存可能成功也可能失败，快速分配策略</code></pre><blockquote><p>声明</p></blockquote><p> <code>在一个对象进入内存时 会进入eden，如果满了（YGC进行回收没有引用的，如果还有引用的）会放入s1或者s0这就涉及到to from哪个为空就是to，（下次eden再次满了会将有数据的【举例s1】中的数据放入s0，并且进行迭代版本）以此类推，当某个对象迭代阈值的次数达到默认15此后，（当然也会有特殊的优化：如当survivor区域中相同年龄的内存总和大于survivor的一半内存，会将大于等于平均年龄的对象提前放入老年代）会放入老年代          关于YGC 全程（YoungGC） 也可以为（Minor GC）  s1，0是不会有单独的gc回收只会被动的依赖于eden的gc当eden进行gc时会自动回收s1，s0</code></p><h3 id="②老年代"><a href="#②老年代" class="headerlink" title="②老年代"></a>②老年代</h3><blockquote><p>特性</p></blockquote><ol><li>较大的对象数据会放入老年代</li><li>老年代的数据都是相对于持久的不会频繁的gc</li><li>(MajorGC / Old GC) 在进行majorgc时会至少进行一次minorGc ，而且majorgc的效率是比minorGc 慢10倍的</li><li>老年代收集器：MajorGC / Old GC 要区分与Full GC  </li></ol><p>Full GC  ：是进行整堆的回收</p><h3 id="③逃逸分析"><a href="#③逃逸分析" class="headerlink" title="③逃逸分析"></a>③逃逸分析</h3><blockquote><p> 什么是逃逸？</p></blockquote><pre><code>也就是如果在方法内创建对象，并且return进行传出，或者赋值到外部的变量，那么就进行了逃逸。-XX:+DoEscapeAnalysis （JDK1.8之后默认开启）-XX:+DoEscapeAnalysis（关闭）</code></pre><blockquote><p>逃逸分析包括以下</p></blockquote><blockquote><p>栈上分配</p></blockquote><p>也就是将对象直接分配到栈上，跟随栈的消亡而消亡，减少了gc（栈中没有gc），提高了性能、速度。</p><blockquote><p>同步省略</p></blockquote><p>因为是每个栈独有的，一个栈也就是一个线程所以不存在同步安全的问题。</p><blockquote><p>分离对象或者标量替换</p></blockquote><p>扩充：一个类代表一个：聚合量，标量是无法分析的最小数据，聚合量可以分析为标量，也就是分析属性</p><p>也就是当加载一个pojo类时，不会创建对象而是，标量替换进行分析成一个个小的属性，减少了内存，提高了性能。</p><p>  但是基于hotSpot 虚拟机这项技术并不成熟，因为还需要进行判断是否 属于逃逸，如果没有逃逸，可能会浪费了判断的时间等一些问题。<br>  但是最后标量替换还是引用到了hotSpot虚拟机中</p><blockquote><p> 所以问题—所有的对象都是存储在堆空间中么？ </p></blockquote><p><code>回答：是的</code></p><hr><h2 id="四、方法区"><a href="#四、方法区" class="headerlink" title="四、方法区"></a>四、方法区</h2><blockquote><p>简介</p></blockquote><ol><li>方法区在Hotspot中又称永久代、元空间（非堆）[这里的永久代、元空间在JVM虚拟机规范中是不等价的]</li><li>在jdk1.7（包含7）以前称为永久代，并且方法区是在JVM中</li><li>在jdk1.8以后称为元空间，并将方法区移除JVM的约束</li><li>使用垃圾收集器：FullGC</li><li>其中内含了常量池、域（Field）信息、已装载类信息、方法信息、JIT代码缓存</li><li>方法区是直接内存（也就是直接分配在内存上的）</li></ol><blockquote><p>存储迁移过程</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524152114118.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>为什么要移除堆空间？</p></blockquote><ol><li>顾名思义（永久代）即经常不回被回收的，跟随电脑的内存进行扩展，可以减少gc，提高性能，并减少了内存溢出的风险。</li></ol><blockquote><p>常量池</p></blockquote><p>常量池包含各种字面量和对类型、域和方法的符号引用。</p><blockquote><p>参数设置</p></blockquote><p>初始值 -XX:MetaspaceSize=100m </p><p>最大值  -XX:MaxMetaspaceSize=100m</p><p><code>建议不要随意修改设置，因可以跟随本地内存变化而进行扩充变化</code></p><hr><ul><li><input disabled type="checkbox"> <strong>经过以上学习类装载子系统、栈、堆、方法区、可延伸面试题：</strong></li></ul><blockquote><p>对象在JVM中是怎么存储的？</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524152230842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><pre><code>答：创建对象的步骤有六种</code></pre><ol><li>判断对象对应的类是否经过类加载子系统加载过</li><li>为对象分配内存</li><li>处理并发安全的问题（TLAB）(CAS)</li><li>初始化分配到空间</li><li>设置对象的对象头</li><li>执行init方法进行初始化</li></ol><blockquote><p>对象头里面有什么？</p></blockquote><ol><li>类型指针—&gt;指向类源数据，确定对象所属类型</li><li>运行时元数据</li></ol><p>声明：如果是数组，还需要记录数组的长度。</p><p><strong>图解流程–以上两问</strong></p><p><img src="https://img-blog.csdnimg.cn/20200524152253476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="五、对象访问定位"><a href="#五、对象访问定位" class="headerlink" title="五、对象访问定位"></a>五、对象访问定位</h2><blockquote><p>句柄访问</p></blockquote><pre><code>通俗来说，就是在栈中的动态链表存储着变量对象在堆空间的引用地址，再开辟一个空间作为中间商来链接堆中的地址，那么栈中的引用直接记录中间商的地址就可以了，当堆空间地址变化了，也不需要进行变化处理。</code></pre><blockquote><p>直接指针（Hotspot使用）</p></blockquote><pre><code>也就指栈中的动态链表存储着变量对象在堆空间的引用地址，是直连的方式，当堆中的地址变化，那么栈中也需要进行变化。</code></pre><hr><h2 id="六、执行引擎"><a href="#六、执行引擎" class="headerlink" title="六、执行引擎"></a>六、执行引擎</h2><ol><li>java代码被编译成字节码的时候可以称为前端编译器，在进行第二次编译为本地系统所能识别的指令称后端编译器</li><li>执行引擎也称后端编译器</li></ol><blockquote><p>执行的流程</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524152421596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>什么是解释器？</p></blockquote><pre><code>也就是将字节码文件翻译为对应平台的机器指令）（低效）运行流程：直接 翻译，直接运行，也就是一行代码一行代码进行编译</code></pre><blockquote><p>什么是编译器？</p></blockquote><pre><code>将源代码直接编译为对应本地平台的机器指令（JIT编译器---》及时编译器）运行流程：先翻译，翻译后再执行，响应时间慢，但是响应过后非常快。解析热点代码（也就是执行频率高的）后会进行缓存起来，下次调用就直接调用的机器指令不需要再次解析，效率高</code></pre><blockquote><p>为什么java是半编译半解释语言？</p></blockquote><p>因为hotspot虚拟机 既有编译器又有解释器互相结合。效率更高</p><blockquote><p>图解</p></blockquote><h2 id><a href="#" class="headerlink" title></a><img src="https://img-blog.csdnimg.cn/2020052415250416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></h2><h2 id="七、垃圾回收器"><a href="#七、垃圾回收器" class="headerlink" title="七、垃圾回收器"></a>七、垃圾回收器</h2><h3 id="①概念。"><a href="#①概念。" class="headerlink" title="①概念。"></a>①概念。</h3><blockquote><p>什么是垃圾？</p></blockquote><p>答：垃圾就是指在运行程序中没有任何指针指向的对象，这个对象就是需要被回收的垃圾。</p><blockquote><p>什么是引用计数算法？（java没有引用这个算法,python使用）</p></blockquote><p> 简单理解来说就是对没一个对象都保存一个整型的计数器，当有人引用时+1 ，不引用了-1，到0时那么就被认定可回收</p><p>优点：简单，高效 </p><p>主要缺点：无法处理循环引用（存在内存泄漏）</p><blockquote><p>吞吐量—延迟性</p></blockquote><p>“程序运行的时间占用总时长的比例”     也就是程序时间/程序时间+垃圾回收时间  占用率越高越好 ，一般高吞吐量的那么都是不需要太大交互的（例如）</p><p>延迟性也就是回收的时候SWT停顿的时间</p><p>两个之间是相对比的，不能同时兼顾极致。</p><blockquote><p>STW</p></blockquote><p>Stop The word ：简称STW 指的是在GC垃圾回收事件时，会产生成语的停顿（会让用户线程进行停顿，进行GC快照）</p><blockquote><p>System.gc()</p></blockquote><p>调用gc（使用的是FullGC） 但是不一定能够及时调到  底层调用的是（Runtime.getRuntime.gc()）;  </p><p><code>一般不会调用，只有在调优测试可能会调用</code></p><h3 id="②GC-Roots"><a href="#②GC-Roots" class="headerlink" title="②GC Roots"></a>②GC Roots</h3><blockquote><p>可达性分析（或 跟搜索算法、追踪性垃圾收集）java使用</p></blockquote><p>关联GC Roots的就是可达性的，对象不应该被回收，不关联的可能会进行回收，看“图文”是否关联</p><blockquote><p>图文理解</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524152528161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>哪些对象是关联GC Roots的？</p></blockquote><ol><li><p>虚拟机栈中的引用对象</p><p>如：各个线程被调用的方法中使用到的参数、局部变量等</p></li><li><p>本地方法栈内JNI（通常说本地方法）引用的对象</p></li><li><p>方法区中类静态属性引用的对象</p></li><li><p>方法区中常量引用的对象</p></li><li><p>所有被同步锁Synchronized只有的对象</p></li><li><p>java虚拟机内部的引用</p></li></ol><h3 id="finalization方法"><a href="#finalization方法" class="headerlink" title="finalization方法"></a>finalization方法</h3><ol><li>finalization方法是父类Object中的一个方法，可以被重载</li><li>finalization方法一般不会去主动调用，因为也没有意义，默认是空的。</li><li>finalization方法是在gc时会自动调用，<code>并且只会触及一次</code></li></ol><blockquote><p>由于方法的存在，可将虚拟机中的对象分为三种</p></blockquote><ol><li>可触及的：冲根节点开始，可以到达这个对象</li><li>可复活的：对象的的引用断开，开始回收，调用了finalization方法又重新引用了。</li><li>不可触及的：也就是对象的引用断开了，并且已经调用过了finalization方法了，只能被回收了</li></ol><blockquote><p>具体过程</p></blockquote><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><blockquote><p>什么是内存泄露？</p></blockquote><p>答：java中对象已经不再使用，但是gc还没办法进行回收</p><blockquote><p>举例</p></blockquote><ol><li>单例模式</li></ol><p>单例的生命周期和应用程序是一样长的，所以单例程序中，如果持有对外部对象的引用的话，那么这个外部对象是不能被回收的，则会导致内.存泄漏的产生。</p><ol start="2"><li>一些提空了close方法关闭资源而没有进行关闭的</li></ol><p>数据库连接(dataSourse . getConnection())，网络连接(socket)和io连接必须手动close，否则是不能被回收的。</p><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><blockquote><p>分带收集</p></blockquote><p>也就是将内存分代进行收集</p><pre><code>如：在java堆分成新生代（eden s1 s2[复制算法]（不会产生内存的碎片化））老年代（标记-清除算法（会参数内存的碎片化，再次存储是空闲列表方式）；标记-整理算法（不会产生碎片化，再次存储时是指针碰撞的方式进行存储））</code></pre><blockquote><p>增量收集算法</p></blockquote><p>一次回收一点，减少延迟性，提高吞吐量</p><blockquote><p>分区算法</p></blockquote><p>就是将堆分为一块一块的小区间region，都相对于是独立的。好处是可以控制一次回收多少个小区间</p><blockquote><p>复制算法</p></blockquote><p>在新生代中使用的就是复制算法。</p><p>优点：不会产生内存的碎片化，运行速度快。</p><p>缺点：如果在不确保是大量垃圾的情况下，可能会导致时间、资源的浪费。</p><blockquote><p>标记–清除算法</p></blockquote><p>将需要进行回收的垃圾进行标记，当进行gc时进行清除（扩充：这里的清除其实并不是在空间中给remove而是标记到空闲列表等待下次进行存储的话直接覆盖），再次存储是空闲列表方式。</p><p>优点：相对比运行速度快</p><p>缺点：内存有碎片化，当存储大容量的对象时可能会导致OOM</p><blockquote><p>标记–整理算法</p></blockquote><p>将需要进行回收的垃圾进行标记，当进行gc时进行清除，清除后，会对内存进行整理不会产生碎片化，再次存储时是指针碰撞的方式进行存储。</p><p>优点：不会有碎片化</p><p>缺点：运行速度较慢</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><blockquote><p>什么时候都可以GC么？</p></blockquote><p>不是什么时候都可以进行直接GC的 只有在制定的安全点才可以</p><p>如何发生GC时，检查所有的线程都跑到了安全点？</p><blockquote><p>抢先式中断：（目前是没有任何商用虚拟机采用）</p></blockquote><p>首先中断用户线程，查看是否到了安全点，如果没有那么继续进行跑（目前是没有任何虚拟机采用）</p><blockquote><p>主动式中断：（大多采用）</p></blockquote><p>设置一个中断的标志，当线程都运行到了主动轮询的标志时，如果中断标志为true，那么进行挂起。</p><h3 id="引用—偏门高频面试"><a href="#引用—偏门高频面试" class="headerlink" title="引用—偏门高频面试"></a>引用—偏门高频面试</h3><p>引用分为：强引用、软、弱、虚引用分别是<code>依次递减</code>的</p><p>引用：当内存空足够时，则保存在内存空间中，如果垃圾回收后，内存空间不够时，那么就抛弃这些对象</p><p>在java中有一个抽象类分别可以实现软、弱、虚</p><p><img src="https://img-blog.csdnimg.cn/20200524152621442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>强引用</p></blockquote><p>平常开发99%都是强引用</p><pre><code>如：String str = new String()</code></pre><blockquote><p>软引用</p></blockquote><p>使用场景：缓存居多</p><p>特点：当内存不够时，那么进行回收，内存够那么继续存在</p><blockquote><p>弱引用</p></blockquote><p>特点：每次gc都会进行直接回收</p><h3 id="HotSpot落地GC"><a href="#HotSpot落地GC" class="headerlink" title="HotSpot落地GC"></a>HotSpot落地GC</h3><p><img src="https://img-blog.csdnimg.cn/20200524152644282.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="Serial—Serial-old"><a href="#Serial—Serial-old" class="headerlink" title="Serial—Serial old"></a>Serial—Serial old</h4><p><code>单核gc处理，串行，针对于新生代的垃圾回收器，采用了复制算法，串行回收----同和Serial old垃圾回收器（收集老年代的垃圾回收器）采用的标记-压缩算法优点：在单线程的情况下，简单高效，一般使用在单cpu精简的情况下主动配置使用SerialGC：-XX:+UseSerialGC</code></p><h4 id="ParNew—CMS-SerialOld"><a href="#ParNew—CMS-SerialOld" class="headerlink" title="ParNew—CMS || SerialOld"></a>ParNew—CMS || SerialOld</h4><p><code>并行回收器，新生代。采用的算法同上。 老年代使用的CMS GC （J14已经移除了）或者SerialOld（J9不再关联） 采用的算法同上；最新版本已经不能使用了主动配置：（必须要在低版本的如J14以下或者J9以下的版本）-XX:+UseParNewGC</code></p><h4 id="Parallel—Parallel-old"><a href="#Parallel—Parallel-old" class="headerlink" title="Parallel—Parallel old"></a>Parallel—Parallel old</h4><p><code>并行回收器，新生代， 效率其实和上面差不多，但是比上面的会更好一点，算法同上，吞吐量更有限可控，自适应调解策略（也就是可以调解吞吐量优先还是 暂停时间优先）---组合Parallel old    jdk1.8默认使用</code></p><h4 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h4><p>在老年代—是一款并发的垃圾处理器–低延迟,采用的是标记-清除算法</p><p>CMS优点：低延迟，并发</p><p>缺点：会产出内存碎片，并且在高峰内存的情况下可能会导致内存不够用那么，就直接执行FullGC回降级使用替补的GC SerialOld）（串行）<br>            无法处理浮动的垃圾<br>            对cpu的资源敏感</p><blockquote><p>为什么说这个是低延迟的？</p></blockquote><p>工作原理：用户线程—》初始标记（STW）GC—》继续用户线程并且并发标记—》重新标记（STW）因为在后面用户线程又进行了使用所有需要重新标记下垃圾—并发清理；</p><blockquote><p>图解原理</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524152704312.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h4><blockquote><p>特点</p></blockquote><ol><li>现在主流G1垃圾回收</li><li>主要应用在服务器端，针对于大内存，多处理器<br>官方说明：延迟可控的情况下尽可能获得更高的吞吐量，所以才担任了“全功能收集器的”重任<pre><code>采用的区域（region）分代化（分区算法）兼具了并行，并发，分区，空间整合，可预测的停顿时间模型Region之间是复制算法，，但整体上可以看做是标记-整理</code></pre></li><li>缺点：内存占用比cms更高</li><li>g1在存储大对象时会专门划分一个区域H区 区别于老年代</li><li>设置H区域的原因 如果创建了一个大对象并且 生命周期很短，放在老年代中，那么就会造成了内存的泄露</li></ol><p><code>声明：G1垃圾回收是分成一块一块Region进行回收，每次回收并不是全部垃圾都进行回收，而是根据延迟时间，来定制收取占比率较高的region</code></p><blockquote><p>记忆集RememberdSet</p></blockquote><p>声明：也就是在因为在g1是进行分区的垃圾回收，所以可能会出现一个区域中使用的对象，在另一个区域中也有引用，那么在回收时就需要全部遍历一遍回收，显然效率太低</p><p>所以有了记忆集：也就是记录了当前年轻代区中的对象在老年代区中的引用位置（如果有那么在ygc时不会回收掉）；</p><blockquote><p>G1垃圾回收过程</p></blockquote><p>G1垃圾回收主要包括三个环节：</p><p>年轻代 YGC</p><p> 老年代并发标记过程(Concurrent Marking)</p><p>混合回收 (Mixed GC)</p><p><img src="https://img-blog.csdnimg.cn/20200524152729721.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p>G1回收过程具体</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200524152741172.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="经典垃圾回收器大致流程图"><a href="#经典垃圾回收器大致流程图" class="headerlink" title="经典垃圾回收器大致流程图"></a>经典垃圾回收器大致流程图</h3><p><img src="https://img-blog.csdnimg.cn/20200524152808420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="七种垃圾回收器总结"><a href="#七种垃圾回收器总结" class="headerlink" title="七种垃圾回收器总结"></a>七种垃圾回收器总结</h3><p><img src="https://img-blog.csdnimg.cn/20200524152823767.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3hpbmNlbjk=,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h2><p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/java.html" target="_blank" rel="noopener">官方参数说明</a></p><pre><code class="hljs java">测试堆空间常用的jvm参数:* -XX:+PrintFlagsInitial :查看所有的参数的默认初始算* -XX:+PrintFlagsFinal :查看所有的参数的最终值(可能会存在修改，不再是初始值)* -Xms: 初始堆空间内存 (默认为物理内存的<span class="hljs-number">1</span>/<span class="hljs-number">64</span>)* -Xmx: 最大堆空间内存(默认为物理内存的<span class="hljs-number">1</span>/<span class="hljs-number">4</span>)* -Xmn: 设置新生代的大小。(初始值及最大值)* -XX:NewRatio: 配置新生代与老年代在堆结构的占比   * -XX:SurvivorRatio: 设置新生代中Eden和se/S1空间的比例* -XX:MaxTenuringThreshold: 设置新生代垃圾的最大年龄 * -XX:+PrintGCDetails: 输出详细的GC处理日志* 打印gc简要信息:⑧-XX:+PrintGC* -XX:HandlePromotionFailure: 是否设置空间分配担保<span class="hljs-comment">//查看默认的垃圾收集器</span>-XX: +PrintCommandLineFlags:查看命令行相关参数(包含使用的垃圾收集器)使用命令行指令: jinfo -flag 相关垃圾回收器参数 进程ID（需要配合jps进程号来使用）<span class="hljs-comment">//例：jinfo -flag UseParallelGC 17948</span>    <span class="hljs-comment">//Parallel 参数</span>-XX:+UseParalle1Gc 手动指定年轻代使用Parallel并行收集器执行内存回收-XX:+UseParallel0ldGc 手动指定老年代都是使用并行回收收集器。（默认两个互相激活，开启一个就可以）-XX: ParallelccThreads 设置年轻代并行收集器的线程数。- -般地，最好与CPU数量相等，以避免过多的线程数影响垃圾收集性能。-XX:MaxGCPauseMillis 设置垃圾收集器最大停顿时间(即STw的时间)。单位ms。 ##谨慎使用-XX:GCTimeRatio垃圾收集时间占总时间的比例(=<span class="hljs-number">1</span>/(N+<span class="hljs-number">1</span>))。用于衡量吞吐量的大小。-XX: +UseAdaptiveSizePolicy 设置Parallel Scavenge收集器具有自适应调节策略 <span class="hljs-comment">//CMS 参数设置</span>-XX: +UseConcMarkSweepGC 手动指定使用CMS收集器执行内存回收任务。-XX: +UseCMSCompactAtFullCollection用于指定在执行完FullGC后对内存空间进行压缩整理，以此避免内存碎片的产生。不过由于内存压缩整理过程无法并发执行，所带来的问题就是停顿时间变得更长了。-XX: CMSFullGCsBeforeCompaction 设置在执行多少次Full GC后对内存空间进行压缩整理。-XX: ParallelCMSThreads设置CMS的线程数量。-XX:CMS1ni tiatingOccupanyFraction 设置堆内存使用率的阈值, 一旦达到该阈值，便开始进行回收。         ➢JDK5及以前版本的默认值为<span class="hljs-number">68</span> ,即当老年代的空间使用率达到<span class="hljs-number">68</span>号时，会执行一次CMS回收。JDK6及 以上版本默认值为<span class="hljs-number">92</span>%        <span class="hljs-comment">//G1 参数设置</span>-XX: +UseG1GC 手动指定使用G1收集器执行内存回收任务。-XX:G1HeapRegionSize设置每个Region的大小。值是<span class="hljs-number">2</span>的幂，范围是<span class="hljs-number">1</span>MB到<span class="hljs-number">32</span>MB之间，目标是根据最小的Java堆大小划分出约<span class="hljs-number">2048</span>个区域。默认是堆内存的<span class="hljs-number">1</span>/<span class="hljs-number">2000</span>.-XX :MaxGCPauseMillis 设置期望达到的最大Gc停顿时间指标(JVM会尽力实现，但不保证达到)。默认值是<span class="hljs-number">200</span>ms-XX: ParallelGCThread 设置STw工作线程数的值。最多设置为<span class="hljs-number">8</span>-XX: ConcGCThreads 设置并发标记的线程数。将n设置为并行垃圾回收线程数(ParallelGCThreads)的<span class="hljs-number">1</span>/<span class="hljs-number">4</span>左右。-XX:InitiatingHeapOccupancyPercent 设 置触发并发GC周期的Java堆占用率阈值。超过此值，就触发GC。默认值是<span class="hljs-number">45</span>。<span class="hljs-comment">//日志的查看</span>-XX:+PrintGC 输出Gc日志。类似: -verbose:gc-XX:+PrintGCDetails 输出Gc的详细日志-XX:+PrintGCTimeStamps 输出Gc的时间戳(以基准时间的形式)-XX:+PrintGCDateStamps 输出GC的时间戳(以日期的形式，如<span class="hljs-number">2013</span>-<span class="hljs-number">05</span>-<span class="hljs-number">04</span>T21 :<span class="hljs-number">53</span>:<span class="hljs-number">59.234</span>+<span class="hljs-number">0800</span>) -XX:+PrintHeapAtGC 在进行Gc的前后打印出堆的信息-Xloggc:.. /logs/gc.log日志文件的输出路径</code></pre>]]></content>
    
    
    <categories>
      
      <category>Basics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
